# 计算机网络

计算机网络知识点

## 为什么三次握手

![UDP 报文](https://camo.githubusercontent.com/4ff2a47d693de1c4fc8b002dd50f5df8c61fee4fcc75c0b610f0d5a5e483b97a/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6c756f676f752f636c6f7564696d672f646174612f32303231303832323136343531392e706e67)

1. 避免历史连接 :star:

   当网络拥堵的情况下，三次握手时一个客户端连续多次发送SYN建立连接的报文，造成一个旧的SNY报文比新的SYN早到服务器端。服务器端会回复一个SYN+ACK报文给客户端，客户端收到后会根据自身的上下文判断这是否是一个历史连接，如果是历史连接则发送一个RST报文给服务器端表示终止。

   比如SYN1的ISN=90，SYN2的ISN=100，那么如果服务器端先收到SYN1的话，发送过来的ACK=90+1，但是客户端期望收到ACK=100+1，所以客户端知道这个给我回复的ACK报文段是历史连接的，我必须发送一个RST报文告诉服务器端终止由这个SYN90报文引起的连接。等SYN100到了我就发送ACK确认报文给服务器端，从而建立连接。

2. 同步双方序列号

3. 避免资源浪费

   在多次行不行，当然行，但是四次已经优化成三次了，再多的话就浪费没必要了。

## 半连接队列(SYN队列)和全连接队列(accept队列)

当服务器第一次收到客户端的 `SYN` 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列也叫做SYN队列

在第三次握手后，客户端收到ACK确认报文后，从SYN队列中移除放到accept队列中，通过调用accept() socketAPI 从accept队列中取出连接队列满了就有可能会出现丢包现象。

## 为什么需要四次挥手

![UDP 报文](https://camo.githubusercontent.com/740b37998486544c041ff17c109122dc4c6b268a6b6b9293cadf94057c2e9452/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6c756f676f752f636c6f7564696d672f646174612f32303231303832323138343133322e706e67)

## TIME_WAIT状态

客户端收到了来自服务器的带有FIN、ACK的结束报文段后并没有直接关闭，而是进入了TIME_WAIT状态

在这个状态中客户端只有等待2MSL(Maximum Segment Life，报文段最大生存时间)才能完全关闭。它是任何报文在网络上存在的最长时间

1. **客户端发送ACK到服务器端的报文最大存活时间**
2. **服务器端从新发送FIN到客户端的报文最大存活时间即2MSL。**

**为什么需要TIME_WAIT？如果没有TIME_WAIT或者TIME_WAIT很短怎么办？**

首先要明白，只有主动发起关闭的一方才有TIME_WAIT状态。

- 防止具有相同「四元组」的「旧」数据包被收到

  假如在客户端向服务端发送FIN即第一次挥手之前，服务器端发送了一个报文给客户端，但因为网络原因这个报文延迟到达了，那么如果TIME_WAIT没有或者太短，由于这个报文具有相同的四元组的旧报文，可能会和新TCP连接的新报文起冲突。

- **TIME_WAIT过多有什么危害？**

  - 占用内存资源

  - 占用端口的资源

    由于客户端使用系统自动分配的临时端口号来建立连接，所以一般不用考虑这个问题。但是服务器可能要考虑，因为服务器的端口号一般是固定的。

## TCP保活机制

当在某个时间段内没有任何连接相关的活动，该机制就会每隔一个时间间隔发送一个探测报文，该报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前连接已经死亡，内核会通知应用程序然后中断连接

## TCP粘包问题

原因：

1. 本质原因：由于TCP是面向字节流传输的，因此数据没有确切的边界，会出现前后两个数据包黏在一起的情况。
2. 发送方。TCP默认使用nagle算法，为了减少网络中报文段的数量。主要有两步，首先上一个分组得到确认后才能发送下一个分组。其次，收集多个小分组然后一起发送。
3. 接收方。当接收方收到数据后不会马上交到应用层去处理，因为发送方和接收方各有两个缓冲空间。接收方收到数据后会将数据放到接收方的读缓存中。这样如果读取的速度小于接收的速度，应用程序可能会读到多个首尾相连的包。

## 拥塞控制

慢开始、拥塞避免、快重传、快恢复

![image-20220302232524645](https://camo.githubusercontent.com/9909cb2fe8a64aee179bd219b78ab63922983af1e6b7d1288b2515cf3b024180/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6c756f676f752f636c6f7564696d672f646174612f3230323230333032323332353734392e706e67)