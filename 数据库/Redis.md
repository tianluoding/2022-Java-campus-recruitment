# Redis

## 五种数据对象

1. SDS 简单动态字符串
2. list链表
   * ziplist
   * linkedlist
3. 字典对象
   * ziplist
   * hashtable
4. 集合对象
   * ziplist
   * hashtable
5. 有序集合
   * ziplist
   * skiplist

## 底层数据结构

底层这些数据结构，都在尽可能为节省内存而考虑

1. SDS

2. list

3. skiplist 

   跳表

   特性：

   1. 跳跃表是有序集合的底层实现之一
   2. 每个跳跃表节点的层高都是1至32之间的随机数
   3. 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序
   4. 跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现

4. inset

   升级不降级的特性，存放16 32 64位的整数

5. ziplist  内存连续 数据移动 连锁更新

   适用于单个数据小，数据量不多的情况

6. hashtable

   特性：

   1. MurmurHash算法，用于计算key的hash值
   2. 每个字典带有两个哈希表，一个平时使用，另一个仅
      在进行rehash时使用
   3. 哈希表使用链地址法来解决键冲突

## redis内存淘汰策略

1. volatile-lru
2. volatile-ttl
3. volatile-random
4. allkeys-lru
5. allkeys-random
6. no-enviction

## 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存击穿、缓存降级

1. 缓存雪崩

   缓存雪崩指的是缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

2. 缓存穿透

   黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承
   受大量 请求而崩掉。

3. 缓存预热

   缓存预热是指系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时
   候，先查询数据库，然后再将数据缓存的问题。用户会直接查询事先被预热的缓存数据！

4. 缓存更新

   除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：
   （1）定时去清理过期的缓存；定时删除
   （2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数
   据并更新缓存。惰性删除

5. 缓存击穿

   缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

6. 缓存降级

   为了保证核心服务可用

## 持久化

1. RDB 快照持久化

   Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本

2. AOF持久化

   开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文
   件

## Redis实现分布式锁

加锁：setnx 解锁：delete

